export const storedFiles = {
	'shaders/blur.frag.c': 'precision highp float;\r\n\r\nvarying vec2 v_texcoord;\r\nuniform sampler2D u_texture;\r\n\r\nuniform vec2 pixelSize;\r\n\r\nvoid main() {\r\n    vec4 scores[9];\r\n    // Top row\r\n    scores[0] = texture2D(u_texture, vec2(v_texcoord.x - 1.0 * pixelSize.x, v_texcoord.y - 1.0 * pixelSize.y));\r\n    scores[1] = texture2D(u_texture, vec2(v_texcoord.x + 0.0 * pixelSize.x, v_texcoord.y - 1.0 * pixelSize.y));\r\n    scores[2] = texture2D(u_texture, vec2(v_texcoord.x + 1.0 * pixelSize.x, v_texcoord.y - 1.0 * pixelSize.y));\r\n       \r\n    // Middle row\r\n    scores[3] = texture2D(u_texture, vec2(v_texcoord.x - 1.0 * pixelSize.x, v_texcoord.y));\r\n    scores[4] = texture2D(u_texture, v_texcoord);  \r\n    scores[5] = texture2D(u_texture, vec2(v_texcoord.x + 1.0 * pixelSize.x, v_texcoord.y));\r\n    \r\n    // Bottom row \r\n    scores[6] = texture2D(u_texture, vec2(v_texcoord.x - 1.0 * pixelSize.x, v_texcoord.y + 1.0 * pixelSize.y));\r\n    scores[7] = texture2D(u_texture, vec2(v_texcoord.x + 0.0 * pixelSize.x, v_texcoord.y + 1.0 * pixelSize.y));\r\n    scores[8] = texture2D(u_texture, vec2(v_texcoord.x + 1.0 * pixelSize.x, v_texcoord.y + 1.0 * pixelSize.y));\r\n\r\n    gl_FragColor = (1.0 / 16.0) * (\r\n        scores[0] + 2.0 * scores[1] + scores[2] +\r\n        2.0 * scores[3] + 4.0 * scores[4] + 2.0 * scores[5] +\r\n        scores[6] + 2.0 * scores[7] + scores[8]\r\n    );\r\n}\r\n', 
	'shaders/canny_hist.frag.c': 'precision highp float;\r\n\r\nvarying vec2 v_texcoord;\r\nuniform sampler2D u_texture;\r\n\r\nuniform vec2 pixelSize;\r\n\r\nvoid main() {\r\n    vec4 scores[9];\r\n\r\n    scores[4] = texture2D(u_texture, v_texcoord);  \r\n\r\n    gl_FragColor = scores[4];\r\n\r\n    if(scores[4].r >= 0.25 && scores[4].r <= 0.75) {\r\n        // Top row\r\n        scores[0] = texture2D(u_texture, vec2(v_texcoord.x - 1.0 * pixelSize.x, v_texcoord.y - 1.0 * pixelSize.y));\r\n        scores[1] = texture2D(u_texture, vec2(v_texcoord.x + 0.0 * pixelSize.x, v_texcoord.y - 1.0 * pixelSize.y));\r\n        scores[2] = texture2D(u_texture, vec2(v_texcoord.x + 1.0 * pixelSize.x, v_texcoord.y - 1.0 * pixelSize.y));\r\n        \r\n        // Middle row\r\n        scores[3] = texture2D(u_texture, vec2(v_texcoord.x - 1.0 * pixelSize.x, v_texcoord.y));\r\n        scores[4] = texture2D(u_texture, v_texcoord);  \r\n        scores[5] = texture2D(u_texture, vec2(v_texcoord.x + 1.0 * pixelSize.x, v_texcoord.y));\r\n        \r\n        // Bottom row \r\n        scores[6] = texture2D(u_texture, vec2(v_texcoord.x - 1.0 * pixelSize.x, v_texcoord.y + 1.0 * pixelSize.y));\r\n        scores[7] = texture2D(u_texture, vec2(v_texcoord.x + 0.0 * pixelSize.x, v_texcoord.y + 1.0 * pixelSize.y));\r\n        scores[8] = texture2D(u_texture, vec2(v_texcoord.x + 1.0 * pixelSize.x, v_texcoord.y + 1.0 * pixelSize.y));\r\n\r\n        if(scores[0].r > 0.75 || scores[1].r > 0.75 || scores[2].r > 0.75 ||\r\n           scores[3].r > 0.75 || scores[5].r > 0.75 ||\r\n           scores[6].r > 0.75 || scores[7].r > 0.75 || scores[8].r > 0.75) {\r\n               gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\r\n           } else {\r\n               gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n           }\r\n    }\r\n}\r\n', 
	'shaders/canny.frag.c': 'precision highp float;\r\n\r\nvarying vec2 v_texcoord;\r\nuniform sampler2D u_texture;\r\n\r\nuniform vec2 pixelSize;\r\nuniform float lowThreshold;\r\nuniform float highThreshold;\r\nuniform bool L2gradient;\r\n\r\n#define PI 3.1415926535897932384626433832795\r\n\r\n/**\r\n * Applies Sobel kernel to coordinate\r\n * returns x and y gradient\r\n */\r\nvec2 sobel(vec2 coord) \r\n{\r\n  vec4 scores[9];\r\n  \r\n  // Top row\r\n  scores[0] = texture2D(u_texture, vec2(coord.x - 1.0 * pixelSize.x, coord.y - 1.0 * pixelSize.y));\r\n  scores[1] = texture2D(u_texture, vec2(coord.x + 0.0 * pixelSize.x, coord.y - 1.0 * pixelSize.y));\r\n  scores[2] = texture2D(u_texture, vec2(coord.x + 1.0 * pixelSize.x, coord.y - 1.0 * pixelSize.y));\r\n    \r\n  // Middle row\r\n  scores[3] = texture2D(u_texture, vec2(coord.x - 1.0 * pixelSize.x, coord.y)); \r\n  scores[5] = texture2D(u_texture, vec2(coord.x + 1.0 * pixelSize.x, coord.y));\r\n  \r\n  // Bottom row \r\n  scores[6] = texture2D(u_texture, vec2(coord.x - 1.0 * pixelSize.x, coord.y + 1.0 * pixelSize.y));\r\n  scores[7] = texture2D(u_texture, vec2(coord.x + 0.0 * pixelSize.x, coord.y + 1.0 * pixelSize.y));\r\n  scores[8] = texture2D(u_texture, vec2(coord.x + 1.0 * pixelSize.x, coord.y + 1.0 * pixelSize.y));\r\n  \r\n  if((coord.x - 1.0 * pixelSize.x) < 0.0)\r\n  {\r\n      scores[0] = vec4(0.0, 0.0, 0.0, 1.0);\r\n      scores[3] = vec4(0.0, 0.0, 0.0, 1.0);\r\n      scores[6] = vec4(0.0, 0.0, 0.0, 1.0);\r\n  } else if(coord.x + 1.0 * pixelSize.x > 1.0) {\r\n      scores[2] = vec4(0.0, 0.0, 0.0, 1.0);\r\n      scores[5] = vec4(0.0, 0.0, 0.0, 1.0);\r\n      scores[8] = vec4(0.0, 0.0, 0.0, 1.0);\r\n  }\r\n  \r\n  if((coord.y - 1.0 * pixelSize.y) < 0.0)\r\n  {\r\n      scores[0] = vec4(0.0, 0.0, 0.0, 1.0);\r\n      scores[1] = vec4(0.0, 0.0, 0.0, 1.0);\r\n      scores[2] = vec4(0.0, 0.0, 0.0, 1.0);\r\n  } else if(coord.y + 1.0 * pixelSize.y > 1.0) {\r\n      scores[6] = vec4(0.0, 0.0, 0.0, 1.0);\r\n      scores[7] = vec4(0.0, 0.0, 0.0, 1.0);\r\n      scores[8] = vec4(0.0, 0.0, 0.0, 1.0);\r\n  }    \r\n\r\n  /**\r\n   * Horizontal gradient\r\n   * [-1 0 +1]\r\n   * [-2 0 +2]\r\n   * [-1 0 +1]\r\n   */  \r\n  float Gx =\r\n     -1.0 * scores[0].r + -2.0 * scores[3].r + -1.0 * scores[6].r + \r\n     +1.0 * scores[2].r + +2.0 * scores[5].r + +1.0 * scores[8].r;\r\n     \r\n  /**\r\n   * Vertical gradient\r\n   * [-1 -2 -1]\r\n   * [ 0  0  0]\r\n   * [+1 +2 +1]\r\n   */\r\n  float Gy = \r\n     -1.0 * scores[0].r + -2.0 * scores[1].r + -1.0 * scores[2].r + \r\n     +1.0 * scores[6].r + +2.0 * scores[7].r + +1.0 * scores[8].r;\r\n     \r\n  return vec2(Gx, Gy);\r\n}\r\n\r\n\r\n/**\r\n * Convert Sobel gradient into angle / quadrant\r\n * 3 2 1\r\n * 0   0\r\n * 1 2 3\r\n */\r\nint sobel2orientation(vec2 s)\r\n{\r\n  // Returns value [-pi, pi] with 0 begin positive x (quadrant 0)\r\n  float orientation = atan(-s.y, s.x) / PI;\r\n  \r\n  if(orientation < -7.0/8.0) {\r\n      return 0;\r\n  } else if(orientation < -5.0/8.0) {\r\n      return 1;\r\n  } else if(orientation < -3.0/8.0) {\r\n      return 2;\r\n  } else if(orientation < -1.0/8.0) {\r\n      return 3;\r\n  } else if(orientation < 1.0/8.0) {\r\n      return 0;\r\n  } else if(orientation < 3.0/8.0) {\r\n      return 1;\r\n  } else if(orientation < 5.0/8.0) {\r\n      return 2;\r\n  } else if(orientation < 7.0/8.0) {\r\n      return 3;\r\n  } else {\r\n      return 0;\r\n  }    \r\n}\r\n\r\n\r\nfloat sobel2magnitude(vec2 s) \r\n{\r\n    if(L2gradient)\r\n        return sqrt(s.x * s.x + s.y * s.y);\r\n    else\r\n        return abs(s.x) + abs(s.y);\r\n}\r\n\r\nvoid main() {\r\n    vec2 centre = sobel(v_texcoord);\r\n    float magnitude = sobel2magnitude(centre);    \r\n    int orientation = sobel2orientation(centre);\r\n    \r\n    float result = 0.0;\r\n    \r\n    if(magnitude > lowThreshold) {\r\n      result = 0.5;\r\n      \r\n      float prev = 0.0;\r\n      float next = 0.0;\r\n      \r\n      // Based on the direction of the sobel gradient, check if we\'re the maximum\r\n      if(orientation == 0) {\r\n        // Left/right\r\n        prev = sobel2magnitude(sobel( vec2(v_texcoord.x - 1.0 * pixelSize.x, v_texcoord.y) )); \r\n        next = sobel2magnitude(sobel( vec2(v_texcoord.x + 1.0 * pixelSize.x, v_texcoord.y) ));\r\n      } else if(orientation == 3) {\r\n        // Top-left to bottom-right\r\n        prev = sobel2magnitude(sobel( vec2(v_texcoord.x - 1.0 * pixelSize.x, v_texcoord.y - 1.0 * pixelSize.y) )); \r\n        next = sobel2magnitude(sobel( vec2(v_texcoord.x + 1.0 * pixelSize.x, v_texcoord.y + 1.0 * pixelSize.y) ));\r\n      } else if(orientation == 2) {\r\n        // Top to bottom\r\n        prev = sobel2magnitude(sobel( vec2(v_texcoord.x, v_texcoord.y - 1.0 * pixelSize.y) )); \r\n        next = sobel2magnitude(sobel( vec2(v_texcoord.x, v_texcoord.y + 1.0 * pixelSize.y) ));\r\n      } else if(orientation == 1) {\r\n        // Top-right to bottom-left\r\n        prev = sobel2magnitude(sobel( vec2(v_texcoord.x + 1.0 * pixelSize.x, v_texcoord.y - 1.0 * pixelSize.y) )); \r\n        next = sobel2magnitude(sobel( vec2(v_texcoord.x - 1.0 * pixelSize.x, v_texcoord.y + 1.0 * pixelSize.y) ));\r\n      }\r\n      \r\n      if(magnitude > prev && magnitude >= next) {\r\n        if(magnitude > highThreshold)\r\n          result = 1.0;\r\n        else\r\n          result = 0.0;\r\n      }\r\n    }\r\n\r\n    gl_FragColor.r = result;\r\n    gl_FragColor.g = result;\r\n    gl_FragColor.b = result;\r\n\r\n    gl_FragColor.a = 1.0;\r\n}\r\n', 
	'shaders/default.frag.c': 'precision highp float;\r\n\r\nvarying vec2 v_texcoord;\r\nuniform sampler2D u_texture;\r\n\r\nuniform vec2 pixelSize;\r\n\r\nvoid main() {        \r\n    vec4 color = texture2D(u_texture, v_texcoord);\r\n    gl_FragColor = color;\r\n}\r\n', 
	'shaders/default.vert.c': 'attribute vec2 a_position;\r\nattribute vec2 a_texcoord;                        \r\n\r\nvarying vec2 v_texcoord;\r\n\r\nvoid main() {\r\n    gl_Position = vec4(a_position, 0.0, 1.0);\r\n    v_texcoord = a_texcoord;\r\n}', 
	'shaders/fast_filter.frag.c': 'precision highp float;\r\n\r\nvarying vec2 v_texcoord;\r\nuniform sampler2D u_texture;\r\n\r\nuniform vec2 pixelSize;\r\nuniform float T;\r\nuniform int subPixel;\r\n\r\n#define sc(r,c) scores[r * 3 + c] \r\n\r\nvec3 subpixel2D(float scores[9])\r\n{\r\n    // the coefficients of the 2d quadratic function least-squares fit:\r\n    float tmp1 = sc(0,0) + sc(0,2) - 2.0 * sc(1,1) + sc(2,0) + sc(2,2);\r\n    float coeff1 = 3.0 * (tmp1 + sc(0,1) - ((sc(1,0) + sc(1,2)) * 2.0) + sc(2,1));\r\n    float coeff2 = 3.0 * (tmp1 - ((sc(0,1) + sc(2,1)) * 2.0) + sc(1,0) + sc(1,2));\r\n    float tmp2 = sc(0,2) - sc(2,0);\r\n    float tmp3 = (sc(0,0) + tmp2 - sc(2,2));\r\n    float tmp4 = tmp3 - 2.0 * tmp2;\r\n    float coeff3 = -3.0 * (tmp3 + sc(0,1) - sc(2,1));\r\n    float coeff4 = -3.0 * (tmp4 + sc(1,0) - sc(1,2));\r\n    float coeff5 = (sc(0,0) - sc(0,2) - sc(2,0) + sc(2,2)) * 2.0;\r\n    float coeff6 = -(sc(0,0) + sc(0,2) - ((sc(1,0) + sc(0,1) + sc(1,2) + sc(2,1)) * 2.0) - 5.0 * sc(1,1) + sc(2,0) + sc(2,2)) * 2.0;\r\n\r\n    // 2nd derivative test:\r\n    float H_det = 4.0 * coeff1 * coeff2 - coeff5 * coeff5;\r\n    \r\n    if(H_det == 0.0) {\r\n        return vec3(coeff6 / 18.0, 0.0, 0.0);\r\n    }\r\n    \r\n    // The maximum must be at one of the 4 patch corners\r\n    if(!(H_det > 0.0 && coeff1 < 0.0)) {\r\n        float tmp_max = coeff3 + coeff4 + coeff5;\r\n        float delta_x = 1.0;\r\n        float delta_y = 1.0;\r\n        \r\n        float tmp = -coeff3 + coeff4 - coeff5;\r\n        if(tmp > tmp_max) {\r\n            tmp_max = tmp;\r\n            delta_x = -1.0;\r\n            delta_y = 1.0;\r\n        }\r\n        \r\n        tmp = coeff3 - coeff4 - coeff5;\r\n        if(tmp > tmp_max) {\r\n            tmp_max = tmp;\r\n            delta_x = 1.0;\r\n            delta_y = -1.0;\r\n        }\r\n        \r\n        tmp = -coeff3 - coeff4 + coeff5;\r\n        if(tmp > tmp_max) {\r\n            tmp_max = tmp;\r\n            delta_x = -1.0;\r\n            delta_y = -1.0;\r\n        }\r\n        \r\n        return vec3((tmp_max + coeff1 + coeff2 + coeff6) / 18.0, delta_x, delta_y);\r\n    }\r\n    \r\n    // Location of maximum\r\n    float delta_x = (2.0 * coeff2 * coeff3 - coeff4 * coeff5) / -H_det;\r\n    float delta_y = (2.0 * coeff1 * coeff4 - coeff3 * coeff5) / -H_det;\r\n    \r\n    // Mmaximum is outside of boundaries\r\n    bool tx = false;\r\n    bool tx_ = false;\r\n    bool ty = false;\r\n    bool ty_ = false;\r\n    \r\n    if(delta_x > 1.0)\r\n        tx = true;\r\n    else if(delta_x < -1.0)\r\n        tx_ = true;\r\n    if(delta_y > 1.0)\r\n        ty = true;\r\n    if(delta_y < -1.0)\r\n        ty = true;\r\n        \r\n    if(tx || tx_ || ty || ty_) {\r\n        float delta_x1 = 0.0, delta_x2 = 0.0, delta_y1 = 0.0, delta_y2 = 0.0;\r\n        if(tx) {\r\n            delta_x1 = 1.0;\r\n            delta_y1 = (coeff4 + coeff5) / (2.0 * coeff2);\r\n            if(delta_y1 > 1.0)\r\n                delta_y1 = 1.0;\r\n            else if(delta_y1 < -1.0)\r\n                delta_y1 = -1.0;\r\n        } else if(tx_) {\r\n            delta_x1 = -1.0;\r\n            delta_y1 = -(coeff4 - coeff5) / (2.0 * coeff2);\r\n            if(delta_y1 > 1.0)\r\n                delta_y1 = 1.0;\r\n            else if(delta_y1 < -1.0)\r\n                delta_y1 = -1.0;\r\n        }\r\n        \r\n        if (ty) {\r\n            delta_y2 = 1.0;\r\n            delta_x2 = -(coeff3 + coeff5) / (2.0 * coeff1);\r\n            if (delta_x2 > 1.0)\r\n                delta_x2 = 1.0;\r\n            else if (delta_x2 < -1.0)\r\n                delta_x2 = -1.0;\r\n        } else if (ty_) {\r\n            delta_y2 = -1.0;\r\n            delta_x2 = -(coeff3 - coeff5) / (2.0 * coeff1);\r\n            if (delta_x2 > 1.0)\r\n                delta_x2 = 1.0;\r\n            else if (delta_x2 < -1.0)\r\n                delta_x2 = -1.0;\r\n        }\r\n        \r\n        float max1 = (coeff1 * delta_x1 * delta_x1 + coeff2 * delta_y1 * delta_y1 + coeff3 * delta_x1 + coeff4 * delta_y1 + coeff5 * delta_x1 * delta_y1 + coeff6) / 18.0;\r\n        float max2 = (coeff1 * delta_x2 * delta_x2 + coeff2 * delta_y2 * delta_y2 + coeff3 * delta_x2 + coeff4 * delta_y2 + coeff5 * delta_x2 * delta_y2 + coeff6) / 18.0;\r\n        \r\n        if (max1 > max2) {\r\n            return vec3(max1, delta_x1, delta_y1);\r\n        } else {\r\n            return vec3(max2, delta_x2, delta_y2);\r\n        }        \r\n    }\r\n    \r\n    float score = (coeff1 * delta_x * delta_x + coeff2 * delta_y * delta_y + coeff3 * delta_x + coeff4 * delta_y + coeff5 * delta_x * delta_y + coeff6) / 18.0;    \r\n    return vec3(score, delta_x, delta_y);\r\n}\r\n\r\nvoid main() {   \r\n    float scores[9];\r\n    // Top row\r\n    scores[0] = texture2D(u_texture, vec2(v_texcoord.x - 1.0 * pixelSize.x, v_texcoord.y - 1.0 * pixelSize.y)).x;\r\n    scores[1] = texture2D(u_texture, vec2(v_texcoord.x, v_texcoord.y - 1.0 * pixelSize.y)).x;\r\n    scores[2] = texture2D(u_texture, vec2(v_texcoord.x + 1.0 * pixelSize.x, v_texcoord.y - 1.0 * pixelSize.y)).x;\r\n       \r\n    // Middle row\r\n    scores[3] = texture2D(u_texture, vec2(v_texcoord.x - 1.0 * pixelSize.x, v_texcoord.y)).x;\r\n    scores[4] = texture2D(u_texture, v_texcoord).x;  \r\n    scores[5] = texture2D(u_texture, vec2(v_texcoord.x + 1.0 * pixelSize.x, v_texcoord.y)).x;\r\n    \r\n    // Bottom row \r\n    scores[6] = texture2D(u_texture, vec2(v_texcoord.x - 1.0 * pixelSize.x, v_texcoord.y + 1.0 * pixelSize.y)).x;\r\n    scores[7] = texture2D(u_texture, vec2(v_texcoord.x, v_texcoord.y + 1.0 * pixelSize.y)).x;\r\n    scores[8] = texture2D(u_texture, vec2(v_texcoord.x + 1.0 * pixelSize.x, v_texcoord.y + 1.0 * pixelSize.y)).x;\r\n\r\n    // Only use scores[4] if it is the largest in the region\r\n    if(scores[4] > scores[0] && scores[4] > scores[1] && scores[4] > scores[2] && scores[4] > scores[3] &&\r\n       scores[4] > scores[5] && scores[4] > scores[6] && scores[4] > scores[7] && scores[4] > scores[8] && \r\n       texture2D(u_texture, v_texcoord).w > 0.0) {\r\n           if(subPixel == 1) {\r\n               gl_FragColor.xyw = subpixel2D(scores);\r\n           } else {\r\n                gl_FragColor.x = scores[4];           \r\n                gl_FragColor.w = scores[4];\r\n           }\r\n    } else {\r\n        gl_FragColor.x = 0.0;\r\n        gl_FragColor.w = 0.0;\r\n    }\r\n}\r\n', 
	'shaders/fast.frag.c': 'precision highp float;\r\n\r\nvarying vec2 v_texcoord;\r\nuniform sampler2D u_texture;\r\n\r\nuniform vec2 pixelSize;\r\nuniform int S;\r\nuniform int mask;\r\nuniform float T;\r\n\r\n\r\n/**\r\n * Output:\r\n *  x -> Score of the feature\r\n *  y/z/w -> Same as x\r\n */\r\nvoid main() {    \r\n    float score = 0.0;\r\n    if(mask == 16)\r\n        score = fast_16_S_score(v_texcoord, u_texture, pixelSize, S) - 1.0 / 256.0;\r\n    else\r\n        score = fast_8_S_score(v_texcoord, u_texture, pixelSize, S) - 1.0 / 256.0;\r\n\r\n    if(score < T) {\r\n        gl_FragColor = vec4(score, 0.0, 0.0, 1.0);\r\n    } else {\r\n        gl_FragColor = vec4(score, score, score, 1.0);\r\n    }\r\n}\r\n', 
	'shaders/gradient.frag.c': 'precision highp float;\r\n\r\nvarying vec2 v_texcoord;\r\nuniform sampler2D u_texture;\r\n\r\nuniform vec2 pixelSize;\r\n\r\nvoid main() {\r\n    vec4 scores[9];\r\n    // Top row\r\n    //scores[0] = texture2D(u_texture, vec2(v_texcoord.x - 1.0 * pixelSize.x, v_texcoord.y - 1.0 * pixelSize.y));\r\n    scores[1] = texture2D(u_texture, vec2(v_texcoord.x + 0.0 * pixelSize.x, v_texcoord.y - 1.0 * pixelSize.y));\r\n    //scores[2] = texture2D(u_texture, vec2(v_texcoord.x + 1.0 * pixelSize.x, v_texcoord.y - 1.0 * pixelSize.y));\r\n       \r\n    // Middle row\r\n    scores[3] = texture2D(u_texture, vec2(v_texcoord.x - 1.0 * pixelSize.x, v_texcoord.y));\r\n    //scores[4] = texture2D(u_texture, v_texcoord);  \r\n    scores[5] = texture2D(u_texture, vec2(v_texcoord.x + 1.0 * pixelSize.x, v_texcoord.y));\r\n    \r\n    // Bottom row \r\n    //scores[6] = texture2D(u_texture, vec2(v_texcoord.x - 1.0 * pixelSize.x, v_texcoord.y + 1.0 * pixelSize.y));\r\n    scores[7] = texture2D(u_texture, vec2(v_texcoord.x + 0.0 * pixelSize.x, v_texcoord.y + 1.0 * pixelSize.y));\r\n    //scores[8] = texture2D(u_texture, vec2(v_texcoord.x + 1.0 * pixelSize.x, v_texcoord.y + 1.0 * pixelSize.y));\r\n\r\n    float horizontal = (scores[5].x - scores[3].x) / 2.0;\r\n    float vertical = (scores[7].x - scores[1].x) / 2.0;\r\n    float magnitude = sqrt(horizontal * horizontal + vertical * vertical);\r\n\r\n    gl_FragColor.r = horizontal + 0.5;\r\n    gl_FragColor.g = vertical + 0.5;\r\n    gl_FragColor.b = magnitude / sqrt(0.5);\r\n\r\n    gl_FragColor.a = 1.0;\r\n}\r\n', 
	'shaders/grayscale.frag.c': 'precision highp float;\r\n\r\nvarying vec2 v_texcoord;\r\nuniform sampler2D u_texture;\r\n\r\nuniform vec2 pixelSize;\r\n\r\nvoid main() {\r\n    vec4 color = texture2D(u_texture, v_texcoord);\r\n\r\n    //float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));\r\n    float gray = dot(color.rgb, vec3(4899.0, 9617.0, 1868.0)) / 16384.0;\r\n\r\n    color = vec4(gray, gray, gray, 1.0);\r\n    gl_FragColor = floor(255.0 * color + 0.5) / 255.0;\r\n}\r\n', 
	'shaders/pyrdown.frag.c': 'precision highp float;\r\n\r\nvarying vec2 v_texcoord;\r\nuniform sampler2D u_texture;\r\n\r\nuniform vec2 pixelSizeIn;\r\nuniform vec2 pixelSizeOut;\r\n\r\n// 1  4  6  4 1\r\n// 4 16 24 16 4\r\n// etc..\r\n\r\n// Border type is: reflex\r\n// gfedcb|abcdefgh|hgedcb\r\n// if x < 0 => -x\r\n// if x > 1 => 1 - x\r\n\r\nvec4 gaussianKernel(sampler2D T, vec2 coord, vec2 size)\r\n{\r\n    vec4 result = vec4(0, 0, 0, 1.0);\r\n\r\n    for(int i = -2; i <= 2; i++) {\r\n        for(int j = -2; j <= 2; j++) {\r\n            float x = coord.x + float(i) * size.x;\r\n            float y = coord.y + float(j) * size.y;\r\n            \r\n            // Reflect\r\n            if(x < 0.0) x = 0.0 - x + size.x;\r\n            if(y < 0.0) y = 0.0 - y + size.y;\r\n            if(x > 1.0) x = 2.0 - x - size.x;\r\n            if(y > 1.0) y = 2.0 - y - size.y;\r\n            \r\n            float weight = 1.0;\r\n            \r\n            if(i == -1 || i == 1) weight *= 4.0;\r\n            if(i == 0) weight *= 6.0;\r\n            \r\n            if(j == -1 || j == 1) weight *= 4.0;\r\n            if(j == 0) weight *= 6.0;\r\n            \r\n            result += weight/256.0 * texture2D(T, vec2(x, y));\r\n        }\r\n    }\r\n    \r\n    return result;\r\n}\r\n\r\nvoid main()\r\n{\r\n    vec4 value = gaussianKernel(u_texture, \r\n        v_texcoord - 0.5 * pixelSizeOut + 0.5 * pixelSizeIn, \r\n        pixelSizeIn);\r\n\r\n    // With 256 => 377126 errors\r\n\r\n    gl_FragColor = floor(255.0 * value + 0.501) / 255.0;\r\n    //gl_FragColor = value;\r\n}\r\n', 
	'shaders/resize.frag.c': 'precision highp float;\r\n\r\nvarying vec2 v_texcoord;\r\nuniform sampler2D u_texture;\r\n\r\nuniform vec2 pixelSizeIn;\r\nuniform vec2 pixelSizeOut;\r\n\r\nuniform float xIn;\r\nuniform float yIn;\r\n\r\nuniform float wIn;\r\nuniform float hIn;\r\n\r\nvoid main() {\r\n    // This performs cropping and resizing\r\n    vec2 Tcoord = (vec2(xIn, yIn) + v_texcoord * vec2(wIn, hIn)) * pixelSizeIn;\r\n    gl_FragColor = texture2D(u_texture, Tcoord);\r\n}\r\n', 
	'shaders/rgbtohsv.frag.c': 'precision highp float;\r\n\r\nvarying vec2 v_texcoord;\r\nuniform sampler2D u_texture;\r\n\r\nuniform vec2 pixelSize;\r\n\r\nvoid main() {\r\n    vec4 color = texture2D(u_texture, v_texcoord);\r\n\r\n    float v = max(max(color.r, color.g), color.b);\r\n    float vmin = min(min(color.r, color.g), color.b);\r\n    \r\n    float diff = v - vmin;\r\n\r\n    // Compute hue\r\n    float h;\r\n    if(v == color.r) {\r\n        h = color.g - color.b;\r\n    } else if(v == color.g) {\r\n        h = color.b - color.r + 2.0 * diff;\r\n    } else if(v == color.b) {\r\n        h = color.r - color.g + 4.0 * diff;\r\n    }\r\n    \r\n    float hr = 180.0;\r\n    float hdiv = floor((hr * 682.0) / diff);\r\n    h = floor(floor(h * hdiv + 2048.0) / 4096.0);\r\n    if(h < 0.0) h += hr;\r\n    \r\n    // Compute saturation\r\n    float s = floor(floor(diff * floor(1044480.0 / v) + 2048.0) / 4096.0);\r\n    \r\n    // Fill result\r\n    gl_FragColor.a = 1.0;\r\n    gl_FragColor.b = h / 255.0;    \r\n    gl_FragColor.g = s / 255.0;\r\n    gl_FragColor.r = v;\r\n}\r\n', 
	'shaders/scale.frag.c': 'precision highp float;\r\n\r\nvarying vec2 v_texcoord;\r\nuniform sampler2D u_texture;\r\n\r\nuniform vec2 pixelSizeIn;\r\nuniform vec2 pixelSizeOut;\r\n\r\nvec4 scaleHalf()\r\n{\r\n    vec2 top_left = v_texcoord;\r\n    vec2 top_right = v_texcoord;\r\n    vec2 bottom_left = v_texcoord;\r\n    vec2 bottom_right = v_texcoord;\r\n    \r\n    top_left.y -= 0.5 * pixelSizeIn.y;\r\n    top_right.y -= 0.5 *pixelSizeIn.y;\r\n    \r\n    bottom_left.y += 0.5 * pixelSizeIn.y;\r\n    bottom_right.y += 0.5 * pixelSizeIn.y;\r\n    \r\n    top_left.x -= 0.5 * pixelSizeIn.x;\r\n    bottom_left.x -= 0.5 * pixelSizeIn.x;\r\n    \r\n    top_right.x += 0.5 * pixelSizeIn.x;\r\n    bottom_right.x += 0.5 * pixelSizeIn.x;\r\n    \r\n    vec4 color;\r\n    \r\n    color += texture2D(u_texture, bottom_left) * 255.0;\r\n    color += texture2D(u_texture, bottom_right) * 255.0;\r\n\r\n    color +=texture2D(u_texture, top_left) * 255.0;\r\n    color += texture2D(u_texture, top_right) * 255.0;\r\n   \r\n    return floor(color / 4.0 + 0.5) / 255.0;        \r\n}\r\n\r\n\r\nvec4 scaleTwoThird()\r\n{\r\n    // First determine which quadrant of the 2x2 field we are in    \r\n    float xeven = mod(floor(v_texcoord.x / pixelSizeOut.x), 2.0);\r\n    float yeven = mod(floor(v_texcoord.y / pixelSizeOut.y), 2.0);\r\n    \r\n    // Then compute the coordinates of the four pixels\r\n    vec2 A = v_texcoord;\r\n    vec2 B = v_texcoord;\r\n    vec2 C = v_texcoord;\r\n    vec2 D = v_texcoord;\r\n    \r\n    // A B  B A  \r\n    // C D  D C\r\n    //\r\n    // C D  D C\r\n    // A B  B A\r\n\r\n    if(xeven < 0.5) {\r\n        A.x = A.x - 0.5 * pixelSizeOut.x + 0.5 * pixelSizeIn.x;        \r\n        B.x = A.x + pixelSizeIn.x;\r\n    } else {\r\n        A.x = A.x - 0.5 * pixelSizeOut.x + 1.0 * pixelSizeIn.x;\r\n        B.x = A.x - pixelSizeIn.x;\r\n    }\r\n\r\n    C.x = A.x;   \r\n    D.x = B.x;\r\n\r\n    if(yeven < 0.5) {\r\n        A.y = A.y - 0.5 * pixelSizeOut.y + 0.5 * pixelSizeIn.y;\r\n        C.y = A.y + pixelSizeIn.y;\r\n    } else {\r\n        A.y = A.y - 0.5 * pixelSizeOut.y + 1.0 * pixelSizeIn.y;\r\n        C.y = A.y - pixelSizeIn.y;\r\n    }\r\n\r\n    B.y = A.y;\r\n    D.y = C.y;\r\n\r\n    vec4 color;\r\n    color += texture2D(u_texture, A) * 255.0 * (2.0 / 3.0) * (2.0 / 3.0);\r\n    color += texture2D(u_texture, B) * 255.0 * (2.0 / 3.0) * (1.0 / 3.0);\r\n    color += texture2D(u_texture, C) * 255.0 * (2.0 / 3.0) * (1.0 / 3.0);\r\n    color += texture2D(u_texture, D) * 255.0 * (1.0 / 3.0) * (1.0 / 3.0);\r\n\r\n    return floor(color + 0.5) / 255.0;\r\n}\r\n\r\n\r\n/**\r\n * This shader only supports 2/3 and 1/2 scaling\r\n * therefore we check to which one the ratio of pixel sizes\r\n * is closest in order to determine which scaler to use.\r\n */\r\nvoid main() \r\n{\r\n    vec4 color;\r\n\r\n    vec2 ratio = pixelSizeIn / pixelSizeOut;    \r\n    float bound = (0.5 + 2.0/3.0) / 2.0;\r\n    \r\n    if(ratio.x >= bound)\r\n        color = scaleTwoThird();\r\n    else\r\n        color = scaleHalf();\r\n    \r\n    gl_FragColor = color;\r\n}\r\n', 
	'shaders/sharpen.frag.c': 'precision highp float;\r\n\r\nvarying vec2 v_texcoord;\r\nuniform sampler2D u_texture;\r\n\r\nuniform vec2 pixelSize;\r\n\r\nvoid main() {\r\n    vec4 scores[9];\r\n    // Top row\r\n    scores[0] = texture2D(u_texture, vec2(v_texcoord.x - 1.0 * pixelSize.x, v_texcoord.y - 1.0 * pixelSize.y));\r\n    scores[1] = texture2D(u_texture, vec2(v_texcoord.x + 0.0 * pixelSize.x, v_texcoord.y - 1.0 * pixelSize.y));\r\n    scores[2] = texture2D(u_texture, vec2(v_texcoord.x + 1.0 * pixelSize.x, v_texcoord.y - 1.0 * pixelSize.y));\r\n       \r\n    // Middle row\r\n    scores[3] = texture2D(u_texture, vec2(v_texcoord.x - 1.0 * pixelSize.x, v_texcoord.y - 1.0 * pixelSize.y));\r\n    scores[4] = texture2D(u_texture, v_texcoord);  \r\n    scores[5] = texture2D(u_texture, vec2(v_texcoord.x + 1.0 * pixelSize.x, v_texcoord.y + 1.0 * pixelSize.y));\r\n    \r\n    // Bottom row \r\n    scores[6] = texture2D(u_texture, vec2(v_texcoord.x - 1.0 * pixelSize.x, v_texcoord.y + 1.0 * pixelSize.y));\r\n    scores[7] = texture2D(u_texture, vec2(v_texcoord.x + 0.0 * pixelSize.x, v_texcoord.y + 1.0 * pixelSize.y));\r\n    scores[8] = texture2D(u_texture, vec2(v_texcoord.x + 1.0 * pixelSize.x, v_texcoord.y + 1.0 * pixelSize.y));\r\n\r\n    gl_FragColor = scores[4] * 5.0 - scores[1] - scores[3] - scores[5] - scores[7];\r\n    gl_FragColor.w = 1.0;\r\n}\r\n', 
	'shaders/sobel.frag.c': 'precision highp float;\r\n\r\nvarying vec2 v_texcoord;\r\nuniform sampler2D u_texture;\r\n\r\nuniform vec2 pixelSize;\r\nuniform bool reportMagOri;\r\n\r\n#define PI 3.1415926535897932384626433832795\r\n\r\n/**\r\n * Perform 3x3 sobel\r\n * If reportMagOri is false:\r\n *   r -> Horizontal\r\n *   g -> Vertical\r\n * If reportMagOri is true:\r\n *   r -> Magnitude\r\n *   g -> Orientation\r\n * \r\n */\r\nvoid main() {\r\n    vec4 scores[9];\r\n    // Top row\r\n    scores[0] = texture2D(u_texture, vec2(v_texcoord.x - 1.0 * pixelSize.x, v_texcoord.y - 1.0 * pixelSize.y));\r\n    scores[1] = texture2D(u_texture, vec2(v_texcoord.x + 0.0 * pixelSize.x, v_texcoord.y - 1.0 * pixelSize.y));\r\n    scores[2] = texture2D(u_texture, vec2(v_texcoord.x + 1.0 * pixelSize.x, v_texcoord.y - 1.0 * pixelSize.y));\r\n       \r\n    // Middle row\r\n    scores[3] = texture2D(u_texture, vec2(v_texcoord.x - 1.0 * pixelSize.x, v_texcoord.y));\r\n    scores[4] = texture2D(u_texture, v_texcoord);  \r\n    scores[5] = texture2D(u_texture, vec2(v_texcoord.x + 1.0 * pixelSize.x, v_texcoord.y));\r\n    \r\n    // Bottom row \r\n    scores[6] = texture2D(u_texture, vec2(v_texcoord.x - 1.0 * pixelSize.x, v_texcoord.y + 1.0 * pixelSize.y));\r\n    scores[7] = texture2D(u_texture, vec2(v_texcoord.x + 0.0 * pixelSize.x, v_texcoord.y + 1.0 * pixelSize.y));\r\n    scores[8] = texture2D(u_texture, vec2(v_texcoord.x + 1.0 * pixelSize.x, v_texcoord.y + 1.0 * pixelSize.y));\r\n\r\n    if((v_texcoord.x - 1.0 * pixelSize.x) < 0.0)\r\n    {\r\n        scores[0] = vec4(0.0, 0.0, 0.0, 1.0);\r\n        scores[3] = vec4(0.0, 0.0, 0.0, 1.0);\r\n        scores[6] = vec4(0.0, 0.0, 0.0, 1.0);\r\n    } else if(v_texcoord.x + 1.0 * pixelSize.x > 1.0) {\r\n        scores[2] = vec4(0.0, 0.0, 0.0, 1.0);\r\n        scores[5] = vec4(0.0, 0.0, 0.0, 1.0);\r\n        scores[8] = vec4(0.0, 0.0, 0.0, 1.0);\r\n    }\r\n    \r\n    if((v_texcoord.y - 1.0 * pixelSize.y) < 0.0)\r\n    {\r\n        scores[0] = vec4(0.0, 0.0, 0.0, 1.0);\r\n        scores[1] = vec4(0.0, 0.0, 0.0, 1.0);\r\n        scores[2] = vec4(0.0, 0.0, 0.0, 1.0);\r\n    } else if(v_texcoord.y + 1.0 * pixelSize.y > 1.0) {\r\n        scores[6] = vec4(0.0, 0.0, 0.0, 1.0);\r\n        scores[7] = vec4(0.0, 0.0, 0.0, 1.0);\r\n        scores[8] = vec4(0.0, 0.0, 0.0, 1.0);\r\n    }    \r\n    \r\n    float horizontal = -1.0 * scores[0].r + -2.0 * scores[3].r + -1.0 * scores[6].r + \r\n                       +1.0 * scores[2].r + +2.0 * scores[5].r + +1.0 * scores[8].r;\r\n                     \r\n    float vertical = -1.0 * scores[0].r + -2.0 * scores[1].r + -1.0 * scores[2].r + \r\n                     +1.0 * scores[6].r + +2.0 * scores[7].r + +1.0 * scores[8].r;\r\n\r\n    if(reportMagOri) {\r\n        gl_FragColor.r = sqrt(horizontal * horizontal + vertical * vertical);\r\n        float orientation = atan(vertical, horizontal);\r\n        \r\n        if(orientation < 1.0/8.0 * PI) {\r\n            gl_FragColor.g = 2.0/3.0;\r\n        } else if(orientation < 3.0/8.0 * PI) {\r\n            gl_FragColor.g = 1.0/3.0;\r\n        } else if(orientation < 5.0/8.0 * PI) {\r\n            gl_FragColor.g = 0.0;\r\n        } else if(orientation < 7.0/8.0 * PI) {\r\n            gl_FragColor.g = 3.0/3.0;\r\n        } else if(orientation < 9.0/8.0 * PI) {\r\n            gl_FragColor.g = 2.0/3.0;\r\n        } else if(orientation < 11.0/8.0 * PI) {\r\n            gl_FragColor.g = 1.0/3.0;\r\n        } else if(orientation < 13.0/8.0 * PI) {\r\n            gl_FragColor.g = 0.0/3.0;\r\n        } else if(orientation < 15.0/8.0 * PI) {\r\n            gl_FragColor.g = 3.0/3.0;\r\n        } else {\r\n            gl_FragColor.g = 2.0/3.0;\r\n        }        \r\n    } else {\r\n        gl_FragColor.r = horizontal;\r\n        gl_FragColor.g = vertical;\r\n    }\r\n                     \r\n    gl_FragColor.a = 1.0;\r\n}\r\n', 
	'shaders/split.frag.c': 'precision highp float;\r\n\r\nvarying vec2 v_texcoord;\r\nuniform sampler2D u_texture;\r\n\r\nuniform vec2 pixelSize;\r\nuniform int channel;\r\n\r\nvoid main() {\r\n    vec4 color = texture2D(u_texture, v_texcoord);\r\n    float value;\r\n\r\n    if(channel == 0) {\r\n        value = color.r;\r\n    } else if(channel == 1) {\r\n        value = color.g;\r\n    } else if(channel == 2) {\r\n        value = color.b;\r\n    }\r\n\r\n    gl_FragColor = vec4(value, value, value, 1.0);\r\n}\r\n', 
	'shaders/lib/fast.frag.c': '/**\r\n * Shader implementation of the FAST [1] algorithm.\r\n *\r\n * Copyright (C) 2015-2016 Ivar Clemens\r\n *\r\n * [1] Fusing points and lines for high performance tracking, Rosten and Drummond\r\n *\r\n * Usage:\r\n *  fast_8_S_score(vec2 coordinate, sampler2D texture, vec2 pixelSize, int S)\r\n *  fast_16_S_score(vec2 coordinate, sampler2D texture, vec2 pixelSize, int S)\r\n */\r\nprecision highp float;\r\n\r\nbool is_a_corner_16(float pixel, float mask[16], int S, float t)\r\n{\r\n    // Lower and higher thresholds\r\n    float t_low = pixel - t;\r\n    float t_high = pixel + t;\r\n    \r\n    bool result = false;\r\n    \r\n    int low_run = 0;\r\n    int high_run = 0;\r\n    int first_low_run = -1;\r\n    int first_high_run = -1;\r\n    \r\n    for(int i = 0; i < 16; i++) {\r\n        // Check for low-run\r\n        if(mask[i] < t_low) {\r\n            low_run++;\r\n        } else {\r\n            if(first_low_run == -1)\r\n                first_low_run = low_run;\r\n            if(low_run >= S)\r\n                result = true;\r\n            low_run = 0;\r\n        }\r\n        \r\n        // Check for high-run\r\n        if(mask[i] > t_high) {\r\n            high_run++;\r\n        } else {\r\n            if(first_high_run == -1)\r\n                first_high_run = high_run;\r\n            if(high_run >= S)\r\n                result = true;\r\n            high_run = 0;\r\n        }\r\n    }\r\n    \r\n    // Make sure segment does not loop around\r\n    if((low_run + first_low_run) >= S || low_run >= S ||\r\n       (high_run + first_high_run) >= S || high_run >= S) {\r\n        result = true;\r\n    }\r\n    \r\n    return result;\r\n} \r\n\r\n\r\nbool is_a_corner_8(float pixel, float mask[8], int S, float t)\r\n{\r\n    // Lower and higher thresholds\r\n    float t_low = pixel - t;\r\n    float t_high = pixel + t;\r\n    \r\n    bool result = false;\r\n    \r\n    int low_run = 0;\r\n    int high_run = 0;\r\n    int first_low_run = -1;\r\n    int first_high_run = -1;\r\n    \r\n    for(int i = 0; i < 8; i++) {\r\n        // Check for low-run\r\n        if(mask[i] < t_low) {\r\n            low_run++;\r\n        } else {\r\n            if(first_low_run == -1)\r\n                first_low_run = low_run;\r\n            if(low_run >= S)\r\n                result = true;\r\n            low_run = 0;\r\n        }\r\n        \r\n        // Check for high-run\r\n        if(mask[i] > t_high) {\r\n            high_run++;\r\n        } else {\r\n            if(first_high_run == -1)\r\n                first_high_run = high_run;\r\n            if(high_run >= S)\r\n                result = true;\r\n            high_run = 0;\r\n        }\r\n    }\r\n    \r\n    // Make sure segment does not loop around\r\n    if((low_run + first_low_run) >= S || low_run >= S ||\r\n       (high_run + first_high_run) >= S || high_run >= S) {\r\n        result = true;\r\n    }\r\n    \r\n    return result;\r\n} \r\n\r\n\r\nfloat fast_8_S_score(vec2 coordinate, sampler2D texture, vec2 pixelSize, int S)\r\n{\r\n    float mask[8];\r\n    mask[0] = texture2D(texture, vec2(coordinate.x - 1.0 * pixelSize.x, coordinate.y - 1.0 * pixelSize.y)).x;\r\n    mask[1] = texture2D(texture, vec2(coordinate.x + 0.0 * pixelSize.x, coordinate.y - 1.0 * pixelSize.y)).x;\r\n    mask[2] = texture2D(texture, vec2(coordinate.x + 1.0 * pixelSize.x, coordinate.y - 1.0 * pixelSize.y)).x;\r\n    mask[3] = texture2D(texture, vec2(coordinate.x + 1.0 * pixelSize.x, coordinate.y + 0.0 * pixelSize.y)).x;  \r\n    mask[4] = texture2D(texture, vec2(coordinate.x + 1.0 * pixelSize.x, coordinate.y + 1.0 * pixelSize.y)).x; \r\n    mask[5] = texture2D(texture, vec2(coordinate.x + 0.0 * pixelSize.x, coordinate.y + 1.0 * pixelSize.y)).x;\r\n    mask[6] = texture2D(texture, vec2(coordinate.x - 1.0 * pixelSize.x, coordinate.y + 1.0 * pixelSize.y)).x;\r\n    mask[7] = texture2D(texture, vec2(coordinate.x - 1.0 * pixelSize.x, coordinate.y + 0.0 * pixelSize.y)).x;\r\n    \r\n    /*\r\n    for(int i = 8; i < 13; i++)\r\n        mask[i] = mask[i - 8];\r\n    \r\n    float pixel = texture2D(texture, coordinate).x;\r\n    \r\n    for(int i = 0; i < 13; i++)\r\n        mask[i] = pixel - mask[i];\r\n       \r\n    float threshold = 10.0/255.0;\r\n        \r\n    float a0 = threshold;\r\n    for(int k = 0; k < 8; k += 2 )\r\n    {\r\n        float a = min(mask[k+1], mask[k+2]);\r\n        if( a <= a0 )\r\n            continue;\r\n        a = min(a, mask[k+3]);\r\n        a = min(a, mask[k+4]);\r\n        a0 = max(a0, min(a, mask[k]));\r\n        a0 = max(a0, min(a, mask[k+5]));\r\n    }\r\n\r\n    float b0 = -a0;\r\n    for(int k = 0; k < 8; k += 2 )\r\n    {\r\n        float b = max(mask[k+1], mask[k+2]);\r\n        b = max(b, mask[k+3]);\r\n        if( b >= b0 )\r\n            continue;\r\n        b = max(b, mask[k+4]);\r\n\r\n        b0 = min(b0, max(b, mask[k]));\r\n        b0 = min(b0, max(b, mask[k+5]));\r\n    }    \r\n\r\n    threshold = -b0;\r\n    \r\n    return threshold;    */\r\n    \r\n   \r\n    // Reject if we\'re processing an edge pixel\r\n    if(coordinate.x < 1.0 * pixelSize.x || \r\n       coordinate.y < 1.0 * pixelSize.y ||\r\n       coordinate.x > 1.0 - 1.0 * pixelSize.x ||\r\n       coordinate.y > 1.0 - 1.0 * pixelSize.y)\r\n        return 0.0;\r\n    \r\n    // Central pixel value\r\n    float pixel = texture2D(texture, coordinate).x;\r\n    \r\n    float t_min = 0.0;\r\n    float t_max = 1.0;    \r\n    \r\n    // Binary search for threshold\r\n    for(int q = 0; q < 8; q++) {\r\n        float t = (t_max + t_min) / 2.0;\r\n        \r\n        if(is_a_corner_8(pixel, mask, S, t))\r\n            t_min = t;\r\n        else\r\n            t_max = t;\r\n    }\r\n    \r\n    return (t_max + t_min) / 2.0;\r\n}\r\n\r\n\r\nfloat fast_16_S_score(vec2 coordinate, sampler2D texture, vec2 pixelSize, int S)\r\n{\r\n    // Get values for surrounding pixels\r\n    float mask[16];\r\n    mask[0] = texture2D(texture, vec2(coordinate.x - 3.0 * pixelSize.x, coordinate.y + 0.0 * pixelSize.y)).x;          \r\n    mask[1] = texture2D(texture, vec2(coordinate.x - 3.0 * pixelSize.x, coordinate.y - 1.0 * pixelSize.y)).x;\r\n    mask[2] = texture2D(texture, vec2(coordinate.x - 2.0 * pixelSize.x, coordinate.y - 2.0 * pixelSize.y)).x;\r\n    mask[3] = texture2D(texture, vec2(coordinate.x - 1.0 * pixelSize.x, coordinate.y - 3.0 * pixelSize.y)).x;\r\n    mask[4] = texture2D(texture, vec2(coordinate.x + 0.0 * pixelSize.x, coordinate.y - 3.0 * pixelSize.y)).x;\r\n    mask[5] = texture2D(texture, vec2(coordinate.x + 1.0 * pixelSize.x, coordinate.y - 3.0 * pixelSize.y)).x;\r\n    mask[6] = texture2D(texture, vec2(coordinate.x + 2.0 * pixelSize.x, coordinate.y - 2.0 * pixelSize.y)).x;\r\n    mask[7] = texture2D(texture, vec2(coordinate.x + 3.0 * pixelSize.x, coordinate.y - 1.0 * pixelSize.y)).x;\r\n    mask[8] = texture2D(texture, vec2(coordinate.x + 3.0 * pixelSize.x, coordinate.y + 0.0 * pixelSize.y)).x;\r\n    mask[9] = texture2D(texture, vec2(coordinate.x + 3.0 * pixelSize.x, coordinate.y + 1.0 * pixelSize.y)).x;\r\n    mask[10] = texture2D(texture, vec2(coordinate.x + 2.0 * pixelSize.x, coordinate.y + 2.0 * pixelSize.y)).x;\r\n    mask[11] = texture2D(texture, vec2(coordinate.x + 1.0 * pixelSize.x, coordinate.y + 3.0 * pixelSize.y)).x;\r\n    mask[12] = texture2D(texture, vec2(coordinate.x + 0.0 * pixelSize.x, coordinate.y + 3.0 * pixelSize.y)).x;\r\n    mask[13] = texture2D(texture, vec2(coordinate.x - 1.0 * pixelSize.x, coordinate.y + 3.0 * pixelSize.y)).x;\r\n    mask[14] = texture2D(texture, vec2(coordinate.x - 2.0 * pixelSize.x, coordinate.y + 2.0 * pixelSize.y)).x;\r\n    mask[15] = texture2D(texture, vec2(coordinate.x - 3.0 * pixelSize.x, coordinate.y + 1.0 * pixelSize.y)).x;    \r\n    \r\n    // Reject if we\'re processing an edge pixel\r\n    if(coordinate.x < 3.0 * pixelSize.x || \r\n       coordinate.y < 3.0 * pixelSize.y ||\r\n       coordinate.x > 1.0 - 3.0 * pixelSize.x ||\r\n       coordinate.y > 1.0 - 3.0 * pixelSize.y)\r\n        return 0.0;\r\n    \r\n    // Central pixel value\r\n    float pixel = texture2D(texture, coordinate).x;\r\n    \r\n    float t_min = 0.0;\r\n    float t_max = 1.0;\r\n    \r\n    // Binary search for threshold\r\n    for(int q = 0; q < 8; q++) {\r\n        float t = (t_max + t_min) / 2.0;\r\n        \r\n        if(is_a_corner_16(pixel, mask, S, t))\r\n            t_min = t;\r\n        else\r\n            t_max = t;\r\n    }\r\n    \r\n    return (t_max + t_min) / 2.0;    \r\n}\r\n', 
};
